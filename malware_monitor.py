import os # for operation system
import sys # for system 
import subprocess # for running process
import psutil # for network and process monitor
import time # timer
from datetime import datetime # for date
from watchdog.observers import Observer # monitor files changes
from watchdog.events import FileSystemEventHandler # monitor file changes


# Constants for paths
MALWARE_DIR = "/sandbox/malware"
MALWARE_PATH = f"{MALWARE_DIR}/{sys.argv[1]}"
REPORT_FILE = "/sandbox/reports/malware_report.txt"

# Check command-line arguments
if len(sys.argv) != 2:
    print("Usage: python3 malware_monitor.py <malware_filename>")
    sys.exit(1)

if not os.path.isfile(MALWARE_PATH):
    print(f"Error: Malware file '{MALWARE_PATH}' not found.")
    sys.exit(1)

# Make sure malware is executable
os.chmod(MALWARE_PATH, 0o755)

# File system monitoring class
class FileMonitorHandler(FileSystemEventHandler):
    def __init__(self):
        self.log = []

    def on_modified(self, event): # if changes
        if not event.is_directory:
            self.log.append(f"Modified: {event.src_path} at {datetime.now()}\n")

    def on_created(self, event): # if created
        if not event.is_directory:
            self.log.append(f"Created: {event.src_path} at {datetime.now()}\n")

    def on_deleted(self, event): # if deleted
        if not event.is_directory:
            self.log.append(f"Deleted: {event.src_path} at {datetime.now()}\n")

# Network activity capture function
def capture_network(duration=10):
    network_log = []
    
    # Start tcpdump in background to a file network.pcap
    pcap_file = "/sandbox/reports/network.pcap"
    tcpdump = subprocess.Popen(
        ["tcpdump", "-i", "any", "-w", pcap_file],
        stdout=subprocess.PIPE, 
        stderr=subprocess.PIPE
    )
    
    # Monitor for open connections
    for _ in range(duration):
        try:
            # Get network connections
            connections = psutil.net_connections(kind='inet')
            for conn in connections:
                if conn.status == 'ESTABLISHED':
                    if hasattr(conn, 'raddr') and conn.raddr:
                        ip = conn.raddr.ip if hasattr(conn.raddr, 'ip') else 'unknown'
                        port = conn.raddr.port if hasattr(conn.raddr, 'port') else 'unknown'
                        local_port = conn.laddr.port if hasattr(conn.laddr, 'port') else 'unknown'
                        
                        try:
                            proc = psutil.Process(conn.pid)
                            proc_name = proc.name()
                            cmdline = ' '.join(proc.cmdline())
                        except:
                            proc_name = "unknown"
                            cmdline = "unknown"
                        
                        connection_info = (
                            f"Process {conn.pid} ({proc_name}) "
                            f"connected from {local_port} to {ip}:{port}\n"
                            f"Command: {cmdline}\n"
                        )
                        if connection_info not in network_log:
                            network_log.append(connection_info)
        except Exception as e:
            network_log.append(f"Error checking connections: {str(e)}\n")
        
        time.sleep(1)
    
    # Stop tcpdump
    tcpdump.terminate()
    try:
        tcpdump.wait(timeout=5)
    except subprocess.TimeoutExpired:
        tcpdump.kill()
    
    if not network_log:
        network_log.append("No network activity detected\n")
    
    return network_log

# Process monitoring function
def monitor_processes(duration=30):
    process_log = []
    initial_processes = {p.pid: p for p in psutil.process_iter(['pid', 'name', 'cmdline', 'create_time'])}
    
    start_time = time.time()
    while time.time() - start_time < duration:
        current_processes = {p.pid: p for p in psutil.process_iter(['pid', 'name', 'cmdline', 'create_time'])}
        
        # Check for new processes
        for pid, proc in current_processes.items():
            if pid not in initial_processes:
                try:
                    proc_info = f"New process: PID={pid}, Name={proc.name()}, Command={' '.join(proc.cmdline() if proc.cmdline() else ['Unknown'])}, Started at {datetime.fromtimestamp(proc.create_time())}\n"
                    process_log.append(proc_info)
                    # Add to initial processes so we don't log it again
                    initial_processes[pid] = proc
                except (psutil.NoSuchProcess, psutil.AccessDenied):
                    pass
        
        # pause to reduce before returning
        time.sleep(0.5)
    
    return process_log

# Main sandbox execution function
def run_sandbox():
    # Initialize file system monitoring
    file_monitor = FileMonitorHandler()
    observer = Observer()
    observer.schedule(file_monitor, path="/sandbox", recursive=True)
    observer.start()

    try:
        # Log that we're about to execute the malware
        print(f"Executing malware sample: {MALWARE_PATH}")
        

        # Determine how to execute the file based on extension
        file_extension = os.path.splitext(MALWARE_PATH)[1].lower()

        if file_extension == '.py':
            cmd = ['python3', MALWARE_PATH]
        elif file_extension == '.sh':
            # Make sure shell scripts are executable
            os.chmod(MALWARE_PATH, 0o755)
            cmd = ['/bin/bash', MALWARE_PATH]
        elif file_extension in ['.exe', '.bin']:
            # For Windows executables or Linux binaries in Wine
            os.chmod(MALWARE_PATH, 0o755)
            cmd = [MALWARE_PATH]
        else:
            # For unknown file types, just try to execute directly
            os.chmod(MALWARE_PATH, 0o755)
            cmd = [MALWARE_PATH]

        # Run the malware sample
        process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        
        # Allow the malware to execute for 30 seconds
        print("Monitoring malware behavior for 30 seconds...")
        start_time = time.time()
        
        # Actively monitor during execution
        process_log = monitor_processes(duration=30)
        network_activity = capture_network(duration=30)
        
        # Check if process is still running and terminate if needed
        if process.poll() is None:
            process.terminate()
            try:
                process.wait(timeout=5)
            except subprocess.TimeoutExpired:
                process.kill()
        
        stdout, stderr = process.communicate()
        
        print(f"Execution completed in {time.time() - start_time:.2f} seconds")

    except Exception as e:
        print(f"Error during execution: {str(e)}")
    finally:
        # Stop the file system observer safely
        observer.stop()
        observer.join()

    # Generate the report file
    with open(REPORT_FILE, "w") as f:
        f.write("==========================================\n")
        f.write("Malware Analysis Report\n")
        f.write("==========================================\n\n")
        f.write(f"Sample: {MALWARE_PATH}\n")
        f.write(f"Analysis Time: {datetime.now()}\n\n")
        
        f.write("EXECUTION DETAILS\n")
        f.write("------------------------------------------\n")
        f.write(f"Return Code: {process.returncode}\n")
        f.write(f"Output: {stdout.decode('utf-8', errors='ignore')}\n")
        f.write(f"Error: {stderr.decode('utf-8', errors='ignore')}\n\n")
        
        f.write("FILE SYSTEM CHANGES\n")
        f.write("------------------------------------------\n")
        if file_monitor.log:
            f.writelines(file_monitor.log)
        else:
            f.write("No file system changes detected.\n")
        
        f.write("\nPROCESS ACTIVITY\n")
        f.write("------------------------------------------\n")
        if process_log:
            f.writelines(process_log)
        else:
            f.write("No new processes detected.\n")
        
        f.write("\nNETWORK ACTIVITY\n")
        f.write("------------------------------------------\n")
        if network_activity:
            f.writelines(network_activity)
        else:
            f.write("No network activity detected.\n")

if __name__ == "__main__":
    try:
        print("hello world")
        run_sandbox()
        print(f"Analysis complete. Report generated in {REPORT_FILE}")
    except Exception as e:
        print(f"Error occurred: {str(e)}")
        # Ensure a report is generated even if an error occurs
        with open(REPORT_FILE, "w") as f:
            f.write(f"Error during analysis: {str(e)}\n")